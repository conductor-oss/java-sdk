// Generated by delombok at Tue Jul 29 15:13:24 CEST 2025
/*
 * Copyright 2022 Conductor Authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * <p>
 * http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */
package com.netflix.conductor.common.metadata.tasks;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CopyOnWriteArrayList;
import org.apache.commons.lang3.StringUtils;
import lombok.*;

public class TaskResult {

    public enum Status {
        IN_PROGRESS, FAILED, FAILED_WITH_TERMINAL_ERROR, COMPLETED;
    }

    private String workflowInstanceId;
    private String taskId;
    private String reasonForIncompletion;
    /**
     * When set to non-zero values, the task remains in the queue for the specified seconds before
     * sent back to the worker when polled. Useful for the long running task, where the task is
     * updated as IN_PROGRESS and should not be polled out of the queue for a specified amount of
     * time. (delayed queue implementation)
     *
     * callbackAfterSeconds Amount of time in seconds the task should be held in the queue
     *     before giving it to a polling worker.
     */
    private long callbackAfterSeconds;
    /**
     * workerId a free form string identifying the worker host. Could be hostname, IP Address
     *     or any other meaningful identifier that can help identify the host/process which executed
     *     the task, in case of troubleshooting.
     */
    private String workerId;
    /**
     * Status of the task
     *     <p><b>IN_PROGRESS</b>: Use this for long running tasks, indicating the task is still in
     *     progress and should be checked again at a later time. e.g. the worker checks the status
     *     of the job in the DB, while the job is being executed by another process.
     *     <p><b>FAILED, FAILED_WITH_TERMINAL_ERROR, COMPLETED</b>: Terminal statuses for the task.
     *     Use FAILED_WITH_TERMINAL_ERROR when you do not want the task to be retried.
     * @see #setCallbackAfterSeconds(long)
     */
    private Status status;
    private Map<String, Object> outputData;
    private List<TaskExecLog> logs;
    private String externalOutputPayloadStoragePath;
    private String subWorkflowId;
    private boolean extendLease;
    private ExecutionMetadata executionMetadata;

    public TaskResult(Task task) {
        this.workflowInstanceId = task.getWorkflowInstanceId();
        this.taskId = task.getTaskId();
        this.reasonForIncompletion = task.getReasonForIncompletion();
        this.callbackAfterSeconds = task.getCallbackAfterSeconds();
        this.workerId = task.getWorkerId();
        this.outputData = task.getOutputData();
        this.externalOutputPayloadStoragePath = task.getExternalOutputPayloadStoragePath();
        this.subWorkflowId = task.getSubWorkflowId();
        this.executionMetadata = task.getExecutionMetadata();
        switch (task.getStatus()) {
        case CANCELED: 
        case COMPLETED_WITH_ERRORS: 
        case TIMED_OUT: 
        case SKIPPED: 
            this.status = Status.FAILED;
            break;
        case SCHEDULED: 
            this.status = Status.IN_PROGRESS;
            break;
        default: 
            this.status = Status.valueOf(task.getStatus().name());
            break;
        }
    }

    public ExecutionMetadata getExecutionMetadata() {
        if (executionMetadata == null) {
            executionMetadata = new ExecutionMetadata();
        }
        return executionMetadata;
    }

    public void setReasonForIncompletion(String reasonForIncompletion) {
        this.reasonForIncompletion = StringUtils.substring(reasonForIncompletion, 0, 500);
    }

    public TaskResult addOutputData(String key, Object value) {
        this.outputData.put(key, value);
        return this;
    }

    public TaskResult log(String log) {
        this.logs.add(new TaskExecLog(log));
        return this;
    }

    public String toString() {
        return "TaskResult{" + "workflowInstanceId=\'" + workflowInstanceId + '\'' + ", taskId=\'" + taskId + '\'' + ", reasonForIncompletion=\'" + reasonForIncompletion + '\'' + ", callbackAfterSeconds=" + callbackAfterSeconds + ", workerId=\'" + workerId + '\'' + ", status=" + status + ", outputData=" + outputData + ", logs=" + logs + ", externalOutputPayloadStoragePath=\'" + externalOutputPayloadStoragePath + '\'' + ", subWorkflowId=\'" + subWorkflowId + '\'' + ", extendLease=\'" + extendLease + '\'' + '}';
    }

    public static TaskResult complete() {
        return newTaskResult(Status.COMPLETED);
    }

    public static TaskResult failed() {
        return newTaskResult(Status.FAILED);
    }

    public static TaskResult failed(String failureReason) {
        TaskResult result = newTaskResult(Status.FAILED);
        result.setReasonForIncompletion(failureReason);
        return result;
    }

    public static TaskResult inProgress() {
        return newTaskResult(Status.IN_PROGRESS);
    }

    public static TaskResult newTaskResult(Status status) {
        TaskResult result = new TaskResult();
        result.setStatus(status);
        return result;
    }

    @java.lang.SuppressWarnings("all")
    private static Map<String, Object> $default$outputData() {
        return new HashMap<>();
    }

    @java.lang.SuppressWarnings("all")
    private static List<TaskExecLog> $default$logs() {
        return new CopyOnWriteArrayList<>();
    }


    @java.lang.SuppressWarnings("all")
    public static class TaskResultBuilder {
        @java.lang.SuppressWarnings("all")
        private String workflowInstanceId;
        @java.lang.SuppressWarnings("all")
        private String taskId;
        @java.lang.SuppressWarnings("all")
        private String reasonForIncompletion;
        @java.lang.SuppressWarnings("all")
        private long callbackAfterSeconds;
        @java.lang.SuppressWarnings("all")
        private String workerId;
        @java.lang.SuppressWarnings("all")
        private Status status;
        @java.lang.SuppressWarnings("all")
        private boolean outputData$set;
        @java.lang.SuppressWarnings("all")
        private Map<String, Object> outputData$value;
        @java.lang.SuppressWarnings("all")
        private boolean logs$set;
        @java.lang.SuppressWarnings("all")
        private List<TaskExecLog> logs$value;
        @java.lang.SuppressWarnings("all")
        private String externalOutputPayloadStoragePath;
        @java.lang.SuppressWarnings("all")
        private String subWorkflowId;
        @java.lang.SuppressWarnings("all")
        private boolean extendLease;
        @java.lang.SuppressWarnings("all")
        private ExecutionMetadata executionMetadata;

        @java.lang.SuppressWarnings("all")
        TaskResultBuilder() {
        }

        /**
         * @return {@code this}.
         */
        @java.lang.SuppressWarnings("all")
        public TaskResult.TaskResultBuilder workflowInstanceId(final String workflowInstanceId) {
            this.workflowInstanceId = workflowInstanceId;
            return this;
        }

        /**
         * @return {@code this}.
         */
        @java.lang.SuppressWarnings("all")
        public TaskResult.TaskResultBuilder taskId(final String taskId) {
            this.taskId = taskId;
            return this;
        }

        /**
         * @return {@code this}.
         */
        @java.lang.SuppressWarnings("all")
        public TaskResult.TaskResultBuilder reasonForIncompletion(final String reasonForIncompletion) {
            this.reasonForIncompletion = reasonForIncompletion;
            return this;
        }

        /**
         * When set to non-zero values, the task remains in the queue for the specified seconds before
         * sent back to the worker when polled. Useful for the long running task, where the task is
         * updated as IN_PROGRESS and should not be polled out of the queue for a specified amount of
         * time. (delayed queue implementation)
         *
         * callbackAfterSeconds Amount of time in seconds the task should be held in the queue
         *     before giving it to a polling worker.
         * @return {@code this}.
         */
        @java.lang.SuppressWarnings("all")
        public TaskResult.TaskResultBuilder callbackAfterSeconds(final long callbackAfterSeconds) {
            this.callbackAfterSeconds = callbackAfterSeconds;
            return this;
        }

        /**
         * workerId a free form string identifying the worker host. Could be hostname, IP Address
         *     or any other meaningful identifier that can help identify the host/process which executed
         *     the task, in case of troubleshooting.
         * @return {@code this}.
         */
        @java.lang.SuppressWarnings("all")
        public TaskResult.TaskResultBuilder workerId(final String workerId) {
            this.workerId = workerId;
            return this;
        }

        /**
         * Status of the task
         *     <p><b>IN_PROGRESS</b>: Use this for long running tasks, indicating the task is still in
         *     progress and should be checked again at a later time. e.g. the worker checks the status
         *     of the job in the DB, while the job is being executed by another process.
         *     <p><b>FAILED, FAILED_WITH_TERMINAL_ERROR, COMPLETED</b>: Terminal statuses for the task.
         *     Use FAILED_WITH_TERMINAL_ERROR when you do not want the task to be retried.
         * @see #setCallbackAfterSeconds(long)
         * @return {@code this}.
         */
        @java.lang.SuppressWarnings("all")
        public TaskResult.TaskResultBuilder status(final Status status) {
            this.status = status;
            return this;
        }

        /**
         * @return {@code this}.
         */
        @java.lang.SuppressWarnings("all")
        public TaskResult.TaskResultBuilder outputData(final Map<String, Object> outputData) {
            this.outputData$value = outputData;
            outputData$set = true;
            return this;
        }

        /**
         * @return {@code this}.
         */
        @java.lang.SuppressWarnings("all")
        public TaskResult.TaskResultBuilder logs(final List<TaskExecLog> logs) {
            this.logs$value = logs;
            logs$set = true;
            return this;
        }

        /**
         * @return {@code this}.
         */
        @java.lang.SuppressWarnings("all")
        public TaskResult.TaskResultBuilder externalOutputPayloadStoragePath(final String externalOutputPayloadStoragePath) {
            this.externalOutputPayloadStoragePath = externalOutputPayloadStoragePath;
            return this;
        }

        /**
         * @return {@code this}.
         */
        @java.lang.SuppressWarnings("all")
        public TaskResult.TaskResultBuilder subWorkflowId(final String subWorkflowId) {
            this.subWorkflowId = subWorkflowId;
            return this;
        }

        /**
         * @return {@code this}.
         */
        @java.lang.SuppressWarnings("all")
        public TaskResult.TaskResultBuilder extendLease(final boolean extendLease) {
            this.extendLease = extendLease;
            return this;
        }

        /**
         * @return {@code this}.
         */
        @java.lang.SuppressWarnings("all")
        public TaskResult.TaskResultBuilder executionMetadata(final ExecutionMetadata executionMetadata) {
            this.executionMetadata = executionMetadata;
            return this;
        }

        @java.lang.SuppressWarnings("all")
        public TaskResult build() {
            Map<String, Object> outputData$value = this.outputData$value;
            if (!this.outputData$set) outputData$value = TaskResult.$default$outputData();
            List<TaskExecLog> logs$value = this.logs$value;
            if (!this.logs$set) logs$value = TaskResult.$default$logs();
            return new TaskResult(this.workflowInstanceId, this.taskId, this.reasonForIncompletion, this.callbackAfterSeconds, this.workerId, this.status, outputData$value, logs$value, this.externalOutputPayloadStoragePath, this.subWorkflowId, this.extendLease, this.executionMetadata);
        }

        @java.lang.Override
        @java.lang.SuppressWarnings("all")
        public java.lang.String toString() {
            return "TaskResult.TaskResultBuilder(workflowInstanceId=" + this.workflowInstanceId + ", taskId=" + this.taskId + ", reasonForIncompletion=" + this.reasonForIncompletion + ", callbackAfterSeconds=" + this.callbackAfterSeconds + ", workerId=" + this.workerId + ", status=" + this.status + ", outputData$value=" + this.outputData$value + ", logs$value=" + this.logs$value + ", externalOutputPayloadStoragePath=" + this.externalOutputPayloadStoragePath + ", subWorkflowId=" + this.subWorkflowId + ", extendLease=" + this.extendLease + ", executionMetadata=" + this.executionMetadata + ")";
        }
    }

    @java.lang.SuppressWarnings("all")
    public static TaskResult.TaskResultBuilder builder() {
        return new TaskResult.TaskResultBuilder();
    }

    @java.lang.SuppressWarnings("all")
    public String getWorkflowInstanceId() {
        return this.workflowInstanceId;
    }

    @java.lang.SuppressWarnings("all")
    public String getTaskId() {
        return this.taskId;
    }

    @java.lang.SuppressWarnings("all")
    public String getReasonForIncompletion() {
        return this.reasonForIncompletion;
    }

    /**
     * When set to non-zero values, the task remains in the queue for the specified seconds before
     * sent back to the worker when polled. Useful for the long running task, where the task is
     * updated as IN_PROGRESS and should not be polled out of the queue for a specified amount of
     * time. (delayed queue implementation)
     *
     * callbackAfterSeconds Amount of time in seconds the task should be held in the queue
     *     before giving it to a polling worker.
     */
    @java.lang.SuppressWarnings("all")
    public long getCallbackAfterSeconds() {
        return this.callbackAfterSeconds;
    }

    /**
     * workerId a free form string identifying the worker host. Could be hostname, IP Address
     *     or any other meaningful identifier that can help identify the host/process which executed
     *     the task, in case of troubleshooting.
     */
    @java.lang.SuppressWarnings("all")
    public String getWorkerId() {
        return this.workerId;
    }

    /**
     * Status of the task
     *     <p><b>IN_PROGRESS</b>: Use this for long running tasks, indicating the task is still in
     *     progress and should be checked again at a later time. e.g. the worker checks the status
     *     of the job in the DB, while the job is being executed by another process.
     *     <p><b>FAILED, FAILED_WITH_TERMINAL_ERROR, COMPLETED</b>: Terminal statuses for the task.
     *     Use FAILED_WITH_TERMINAL_ERROR when you do not want the task to be retried.
     * @see #setCallbackAfterSeconds(long)
     */
    @java.lang.SuppressWarnings("all")
    public Status getStatus() {
        return this.status;
    }

    @java.lang.SuppressWarnings("all")
    public Map<String, Object> getOutputData() {
        return this.outputData;
    }

    @java.lang.SuppressWarnings("all")
    public List<TaskExecLog> getLogs() {
        return this.logs;
    }

    @java.lang.SuppressWarnings("all")
    public String getExternalOutputPayloadStoragePath() {
        return this.externalOutputPayloadStoragePath;
    }

    @java.lang.SuppressWarnings("all")
    public String getSubWorkflowId() {
        return this.subWorkflowId;
    }

    @java.lang.SuppressWarnings("all")
    public boolean isExtendLease() {
        return this.extendLease;
    }

    @java.lang.SuppressWarnings("all")
    public void setWorkflowInstanceId(final String workflowInstanceId) {
        this.workflowInstanceId = workflowInstanceId;
    }

    @java.lang.SuppressWarnings("all")
    public void setTaskId(final String taskId) {
        this.taskId = taskId;
    }

    /**
     * When set to non-zero values, the task remains in the queue for the specified seconds before
     * sent back to the worker when polled. Useful for the long running task, where the task is
     * updated as IN_PROGRESS and should not be polled out of the queue for a specified amount of
     * time. (delayed queue implementation)
     *
     * callbackAfterSeconds Amount of time in seconds the task should be held in the queue
     *     before giving it to a polling worker.
     */
    @java.lang.SuppressWarnings("all")
    public void setCallbackAfterSeconds(final long callbackAfterSeconds) {
        this.callbackAfterSeconds = callbackAfterSeconds;
    }

    /**
     * workerId a free form string identifying the worker host. Could be hostname, IP Address
     *     or any other meaningful identifier that can help identify the host/process which executed
     *     the task, in case of troubleshooting.
     */
    @java.lang.SuppressWarnings("all")
    public void setWorkerId(final String workerId) {
        this.workerId = workerId;
    }

    /**
     * Status of the task
     *     <p><b>IN_PROGRESS</b>: Use this for long running tasks, indicating the task is still in
     *     progress and should be checked again at a later time. e.g. the worker checks the status
     *     of the job in the DB, while the job is being executed by another process.
     *     <p><b>FAILED, FAILED_WITH_TERMINAL_ERROR, COMPLETED</b>: Terminal statuses for the task.
     *     Use FAILED_WITH_TERMINAL_ERROR when you do not want the task to be retried.
     * @see #setCallbackAfterSeconds(long)
     */
    @java.lang.SuppressWarnings("all")
    public void setStatus(final Status status) {
        this.status = status;
    }

    @java.lang.SuppressWarnings("all")
    public void setOutputData(final Map<String, Object> outputData) {
        this.outputData = outputData;
    }

    @java.lang.SuppressWarnings("all")
    public void setLogs(final List<TaskExecLog> logs) {
        this.logs = logs;
    }

    @java.lang.SuppressWarnings("all")
    public void setExternalOutputPayloadStoragePath(final String externalOutputPayloadStoragePath) {
        this.externalOutputPayloadStoragePath = externalOutputPayloadStoragePath;
    }

    @java.lang.SuppressWarnings("all")
    public void setSubWorkflowId(final String subWorkflowId) {
        this.subWorkflowId = subWorkflowId;
    }

    @java.lang.SuppressWarnings("all")
    public void setExtendLease(final boolean extendLease) {
        this.extendLease = extendLease;
    }

    @java.lang.SuppressWarnings("all")
    public void setExecutionMetadata(final ExecutionMetadata executionMetadata) {
        this.executionMetadata = executionMetadata;
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("all")
    public boolean equals(final java.lang.Object o) {
        if (o == this) return true;
        if (!(o instanceof TaskResult)) return false;
        final TaskResult other = (TaskResult) o;
        if (!other.canEqual((java.lang.Object) this)) return false;
        if (this.getCallbackAfterSeconds() != other.getCallbackAfterSeconds()) return false;
        if (this.isExtendLease() != other.isExtendLease()) return false;
        final java.lang.Object this$workflowInstanceId = this.getWorkflowInstanceId();
        final java.lang.Object other$workflowInstanceId = other.getWorkflowInstanceId();
        if (this$workflowInstanceId == null ? other$workflowInstanceId != null : !this$workflowInstanceId.equals(other$workflowInstanceId)) return false;
        final java.lang.Object this$taskId = this.getTaskId();
        final java.lang.Object other$taskId = other.getTaskId();
        if (this$taskId == null ? other$taskId != null : !this$taskId.equals(other$taskId)) return false;
        final java.lang.Object this$reasonForIncompletion = this.getReasonForIncompletion();
        final java.lang.Object other$reasonForIncompletion = other.getReasonForIncompletion();
        if (this$reasonForIncompletion == null ? other$reasonForIncompletion != null : !this$reasonForIncompletion.equals(other$reasonForIncompletion)) return false;
        final java.lang.Object this$workerId = this.getWorkerId();
        final java.lang.Object other$workerId = other.getWorkerId();
        if (this$workerId == null ? other$workerId != null : !this$workerId.equals(other$workerId)) return false;
        final java.lang.Object this$status = this.getStatus();
        final java.lang.Object other$status = other.getStatus();
        if (this$status == null ? other$status != null : !this$status.equals(other$status)) return false;
        final java.lang.Object this$outputData = this.getOutputData();
        final java.lang.Object other$outputData = other.getOutputData();
        if (this$outputData == null ? other$outputData != null : !this$outputData.equals(other$outputData)) return false;
        final java.lang.Object this$logs = this.getLogs();
        final java.lang.Object other$logs = other.getLogs();
        if (this$logs == null ? other$logs != null : !this$logs.equals(other$logs)) return false;
        final java.lang.Object this$externalOutputPayloadStoragePath = this.getExternalOutputPayloadStoragePath();
        final java.lang.Object other$externalOutputPayloadStoragePath = other.getExternalOutputPayloadStoragePath();
        if (this$externalOutputPayloadStoragePath == null ? other$externalOutputPayloadStoragePath != null : !this$externalOutputPayloadStoragePath.equals(other$externalOutputPayloadStoragePath)) return false;
        final java.lang.Object this$subWorkflowId = this.getSubWorkflowId();
        final java.lang.Object other$subWorkflowId = other.getSubWorkflowId();
        if (this$subWorkflowId == null ? other$subWorkflowId != null : !this$subWorkflowId.equals(other$subWorkflowId)) return false;
        final java.lang.Object this$executionMetadata = this.getExecutionMetadata();
        final java.lang.Object other$executionMetadata = other.getExecutionMetadata();
        if (this$executionMetadata == null ? other$executionMetadata != null : !this$executionMetadata.equals(other$executionMetadata)) return false;
        return true;
    }

    @java.lang.SuppressWarnings("all")
    protected boolean canEqual(final java.lang.Object other) {
        return other instanceof TaskResult;
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("all")
    public int hashCode() {
        final int PRIME = 59;
        int result = 1;
        final long $callbackAfterSeconds = this.getCallbackAfterSeconds();
        result = result * PRIME + (int) ($callbackAfterSeconds >>> 32 ^ $callbackAfterSeconds);
        result = result * PRIME + (this.isExtendLease() ? 79 : 97);
        final java.lang.Object $workflowInstanceId = this.getWorkflowInstanceId();
        result = result * PRIME + ($workflowInstanceId == null ? 43 : $workflowInstanceId.hashCode());
        final java.lang.Object $taskId = this.getTaskId();
        result = result * PRIME + ($taskId == null ? 43 : $taskId.hashCode());
        final java.lang.Object $reasonForIncompletion = this.getReasonForIncompletion();
        result = result * PRIME + ($reasonForIncompletion == null ? 43 : $reasonForIncompletion.hashCode());
        final java.lang.Object $workerId = this.getWorkerId();
        result = result * PRIME + ($workerId == null ? 43 : $workerId.hashCode());
        final java.lang.Object $status = this.getStatus();
        result = result * PRIME + ($status == null ? 43 : $status.hashCode());
        final java.lang.Object $outputData = this.getOutputData();
        result = result * PRIME + ($outputData == null ? 43 : $outputData.hashCode());
        final java.lang.Object $logs = this.getLogs();
        result = result * PRIME + ($logs == null ? 43 : $logs.hashCode());
        final java.lang.Object $externalOutputPayloadStoragePath = this.getExternalOutputPayloadStoragePath();
        result = result * PRIME + ($externalOutputPayloadStoragePath == null ? 43 : $externalOutputPayloadStoragePath.hashCode());
        final java.lang.Object $subWorkflowId = this.getSubWorkflowId();
        result = result * PRIME + ($subWorkflowId == null ? 43 : $subWorkflowId.hashCode());
        final java.lang.Object $executionMetadata = this.getExecutionMetadata();
        result = result * PRIME + ($executionMetadata == null ? 43 : $executionMetadata.hashCode());
        return result;
    }

    @java.lang.SuppressWarnings("all")
    public TaskResult() {
        this.outputData = TaskResult.$default$outputData();
        this.logs = TaskResult.$default$logs();
    }

    @java.lang.SuppressWarnings("all")
    private TaskResult(final String workflowInstanceId, final String taskId, final String reasonForIncompletion, final long callbackAfterSeconds, final String workerId, final Status status, final Map<String, Object> outputData, final List<TaskExecLog> logs, final String externalOutputPayloadStoragePath, final String subWorkflowId, final boolean extendLease, final ExecutionMetadata executionMetadata) {
        this.workflowInstanceId = workflowInstanceId;
        this.taskId = taskId;
        this.reasonForIncompletion = reasonForIncompletion;
        this.callbackAfterSeconds = callbackAfterSeconds;
        this.workerId = workerId;
        this.status = status;
        this.outputData = outputData;
        this.logs = logs;
        this.externalOutputPayloadStoragePath = externalOutputPayloadStoragePath;
        this.subWorkflowId = subWorkflowId;
        this.extendLease = extendLease;
        this.executionMetadata = executionMetadata;
    }
}
